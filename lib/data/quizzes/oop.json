[
  {
    "id": "1",
    "title": "Classes and Objects",
    "description": "Test your understanding of classes and objects in Python.",
    "difficulty": "intermediate",
    "questions": [
      {
        "id": "1",
        "type": "multiple-choice",
        "question": "What is a class in Python?",
        "options": [
          "A blueprint for creating objects",
          "An instance of an object",
          "A built-in data type",
          "A function definition"
        ],
        "correctAnswer": "A blueprint for creating objects",
        "explanation": "A class is a blueprint or template for creating objects that defines their structure and behavior."
      },
      {
        "id": "2",
        "type": "text-input",
        "question": "What keyword is used to define a class in Python?",
        "correctAnswer": "class",
        "explanation": "The 'class' keyword is used to define a new class in Python."
      },
      {
        "id": "3",
        "type": "multiple-choice",
        "question": "What is an object in Python?",
        "options": [
          "An instance of a class",
          "A class definition",
          "A module",
          "A function"
        ],
        "correctAnswer": "An instance of a class",
        "explanation": "An object is an instance of a class that has its own attributes and methods."
      },
      {
        "id": "4",
        "type": "multiple-choice",
        "question": "Write the Python code to define a simple class called 'Car' with an __init__ method that takes a 'color' parameter.",
        "options": [
          "class Car:\\n    def __init__(self, color):\\n        self.color = color",
          "#class Car:\\n    def __init__(self, color):\\n        self.color = color",
          "class Car:\\n    def __init__[self, color]:\\n        self.color = color",
          "CLASS CAR:\\N    DEF __INIT__(SELF, COLOR):\\N        SELF.COLOR = COLOR"
        ],
        "correctAnswer": "class Car:\\n    def __init__(self, color):\\n        self.color = color",
        "explanation": "Classes are defined with the 'class' keyword, and __init__ is the constructor method."
      },
      {
        "id": "5",
        "type": "multiple-choice",
        "question": "What is the purpose of the __init__ method?",
        "options": [
          "To initialize object attributes",
          "To create class methods",
          "To define class variables",
          "To inherit from parent classes"
        ],
        "correctAnswer": "To initialize object attributes",
        "explanation": "The __init__ method is called when an object is created and is used to initialize the object's attributes."
      }
    ]
  },
  {
    "id": "2",
    "title": "Inheritance",
    "description": "Practice with inheritance concepts in Python.",
    "difficulty": "intermediate",
    "questions": [
      {
        "id": "1",
        "type": "multiple-choice",
        "question": "What does inheritance allow in OOP?",
        "options": [
          "A class to inherit attributes and methods from another class",
          "Objects to share methods",
          "Classes to be converted to objects",
          "Methods to be called without instances"
        ],
        "correctAnswer": "A class to inherit attributes and methods from another class",
        "explanation": "Inheritance allows a child class to inherit properties and methods from a parent class."
      },
      {
        "id": "2",
        "type": "multiple-choice",
        "question": "Write the Python code to create a class 'Dog' that inherits from 'Animal'.",
        "options": [
          "class Dog(Animal):\n    pass",
          "#class Dog(Animal):\n    pass",
          "class Dog[Animal]:\n    pass",
          "CLASS DOG(ANIMAL):\n    PASS"
        ],
        "correctAnswer": "class Dog(Animal):\n    pass",
        "explanation": "Inheritance is specified by putting the parent class name in parentheses after the child class name."
      },
      {
        "id": "3",
        "type": "multiple-choice",
        "question": "What is method overriding?",
        "options": [
          "Redefining a parent class method in a child class",
          "Calling a parent method from a child",
          "Creating new methods in child classes",
          "Deleting methods from parent classes"
        ],
        "correctAnswer": "Redefining a parent class method in a child class",
        "explanation": "Method overriding allows a child class to provide its own implementation of a method defined in the parent class."
      },
      {
        "id": "4",
        "type": "multiple-choice",
        "question": "Write a class with a method that overrides a parent method.",
        "options": [
          "class Animal:\\n    def speak(self):\\n        return 'Some sound'\\n\\nclass Dog(Animal):\\n    def speak(self):\\n        return 'Woof'",
          "#class Animal:\\n    def speak(self):\\n        return 'Some sound'\\n\\nclass Dog(Animal):\\n    def speak(self):\\n        return 'Woof'",
          "class Animal:\\n    def speak[self]:\\n        return 'Some sound'\\n\\nclass Dog[Animal]:\\n    def speak[self]:\\n        return 'Woof'",
          "CLASS ANIMAL:\\N    DEF SPEAK(SELF):\\N        RETURN 'SOME SOUND'\\N\\NCLASS DOG(ANIMAL):\\N    DEF SPEAK(SELF):\\N        RETURN 'WOOF'"
        ],
        "correctAnswer": "class Animal:\\n    def speak(self):\\n        return 'Some sound'\\n\\nclass Dog(Animal):\\n    def speak(self):\\n        return 'Woof'",
        "explanation": "Child classes can override parent methods by defining methods with the same name."
      },
      {
        "id": "5",
        "type": "text-input",
        "question": "What is method overloading in Python?",
        "correctAnswer": "not supported natively",
        "explanation": "Python doesn't support method overloading like other languages. Use default parameters instead."
      },
      {
        "id": "6",
        "type": "multiple-choice",
        "question": "What is encapsulation in OOP?",
        "options": [
          "Hiding internal details",
          "Combining data and methods",
          "Inheriting from parent classes",
          "Overriding methods"
        ],
        "correctAnswer": "Hiding internal details",
        "explanation": "Encapsulation hides the internal implementation details of a class from outside access."
      },
      {
        "id": "7",
        "type": "multiple-choice",
        "question": "Write a class with private attributes using name mangling.",
        "options": [
          "class MyClass:\\n    def __init__(self):\\n        self.__private = 42\\n    \\n    def get_private(self):\\n        return self.__private",
          "#class MyClass:\\n    def __init__(self):\\n        self.__private = 42\\n    \\n    def get_private(self):\\n        return self.__private",
          "class MyClass:\\n    def __init__[self]:\\n        self.__private = 42\\n    \\n    def get_private[self]:\\n        return self.__private",
          "CLASS MYCLASS:\\N    DEF __INIT__(SELF):\\N        SELF.__PRIVATE = 42\\N    \\N    DEF GET_PRIVATE(SELF):\\N        RETURN SELF.__PRIVATE"
        ],
        "correctAnswer": "class MyClass:\\n    def __init__(self):\\n        self.__private = 42\\n    \\n    def get_private(self):\\n        return self.__private",
        "explanation": "Double underscores prefix private attributes, which are name-mangled to prevent accidental access."
      },
      {
        "id": "8",
        "type": "text-input",
        "question": "What is the difference between a class attribute and an instance attribute?",
        "correctAnswer": "class attributes are shared, instance attributes are unique",
        "explanation": "Class attributes are shared by all instances, while instance attributes are unique to each object."
      },
      {
        "id": "9",
        "type": "multiple-choice",
        "question": "Write a class with both class and instance attributes.",
        "options": [
          "class Car:\\n    wheels = 4  # class attribute\\n    \\n    def __init__(self, color):\\n        self.color = color  # instance attribute",
          "#class Car:\\n    wheels = 4  # class attribute\\n    \\n    def __init__(self, color):\\n        self.color = color  # instance attribute",
          "class Car:\\n    wheels = 4  # class attribute\\n    \\n    def __init__[self, color]:\\n        self.color = color  # instance attribute",
          "CLASS CAR:\\N    WHEELS = 4  # CLASS ATTRIBUTE\\N    \\N    DEF __INIT__(SELF, COLOR):\\N        SELF.COLOR = COLOR  # INSTANCE ATTRIBUTE"
        ],
        "correctAnswer": "class Car:\\n    wheels = 4  # class attribute\\n    \\n    def __init__(self, color):\\n        self.color = color  # instance attribute",
        "explanation": "Class attributes are defined outside __init__, instance attributes inside __init__ with self."
      },
      {
        "id": "10",
        "type": "multiple-choice",
        "question": "What is the MRO in Python?",
        "options": [
          "Method Resolution Order",
          "Multiple Return Objects",
          "Method Return Override",
          "Module Reference Object"
        ],
        "correctAnswer": "Method Resolution Order",
        "explanation": "MRO determines the order in which base classes are searched when looking for a method."
      },
      {
        "id": "11",
        "type": "text-input",
        "question": "What is multiple inheritance?",
        "correctAnswer": "inheriting from multiple parent classes",
        "explanation": "A class can inherit from multiple parent classes, combining their functionality."
      },
      {
        "id": "12",
        "type": "multiple-choice",
        "question": "Write a class that inherits from multiple parents.",
        "options": [
          "class FlyingCar(Car, Airplane):\\n    def fly(self):\\n        return 'Flying!'",
          "#class FlyingCar(Car, Airplane):\\n    def fly(self):\\n        return 'Flying!'",
          "class FlyingCar[Car, Airplane]:\\n    def fly[self]:\\n        return 'Flying!'",
          "CLASS FLYINGCAR(CAR, AIRPLANE):\\N    DEF FLY(SELF):\\N        RETURN 'FLYING!'"
        ],
        "correctAnswer": "class FlyingCar(Car, Airplane):\\n    def fly(self):\\n        return 'Flying!'",
        "explanation": "Multiple inheritance is specified by listing multiple parent classes in parentheses."
      },
      {
        "id": "13",
        "type": "text-input",
        "question": "What is the super() function used for?",
        "correctAnswer": "calling parent class methods",
        "explanation": "super() allows you to call methods from parent classes in overridden methods."
      },
      {
        "id": "14",
        "type": "multiple-choice",
        "question": "Write code using super() to call a parent method.",
        "options": [
          "class Child(Parent):\\n    def __init__(self, value):\\n        super().__init__(value)\\n        self.child_value = value * 2",
          "#class Child(Parent):\\n    def __init__(self, value):\\n        super().__init__(value)\\n        self.child_value = value * 2",
          "class Child[Parent]:\\n    def __init__[self, value]:\\n        super[].__init__[value]\\n        self.child_value = value * 2",
          "CLASS CHILD(PARENT):\\N    DEF __INIT__(SELF, VALUE):\\N        SUPER().__INIT__(VALUE)\\N        SELF.CHILD_VALUE = VALUE * 2"
        ],
        "correctAnswer": "class Child(Parent):\\n    def __init__(self, value):\\n        super().__init__(value)\\n        self.child_value = value * 2",
        "explanation": "super() is commonly used in __init__ to initialize parent class attributes."
      },
      {
        "id": "15",
        "type": "multiple-choice",
        "question": "What is a class method in Python?",
        "options": [
          "A method that works on instances",
          "A method that works on the class",
          "A static method",
          "A private method"
        ],
        "correctAnswer": "A method that works on the class",
        "explanation": "Class methods are decorated with @classmethod and take 'cls' as the first parameter."
      },
      {
        "id": "16",
        "type": "multiple-choice",
        "question": "Write a class method.",
        "options": [
          "@classmethod\\ndef from_string(cls, string):\\n    return cls(string.split(','))",
          "#@classmethod\\ndef from_string(cls, string):\\n    return cls(string.split(','))",
          "@classmethod\\ndef from_string[cls, string]:\\n    return cls[string.split[',']]",
          "@CLASSMETHOD\\NDEF FROM_STRING(CLS, STRING):\\N    RETURN CLS(STRING.SPLIT(','))"
        ],
        "correctAnswer": "@classmethod\\ndef from_string(cls, string):\\n    return cls(string.split(','))",
        "explanation": "Class methods can be used as alternative constructors or for class-level operations."
      },
      {
        "id": "17",
        "type": "multiple-choice",
        "question": "What is a static method?",
        "options": [
          "A method that doesn't access instance or class data",
          "A method that accesses class data",
          "A method that accesses instance data",
          "A private method"
        ],
        "correctAnswer": "A method that doesn't access instance or class data",
        "explanation": "Static methods are decorated with @staticmethod and don't take self or cls parameters."
      },
      {
        "id": "18",
        "type": "multiple-choice",
        "question": "Write a static method.",
        "options": [
          "@staticmethod\\ndef is_valid_age(age):\\n    return 0 <= age <= 150",
          "#@staticmethod\\ndef is_valid_age(age):\\n    return 0 <= age <= 150",
          "@staticmethod\\ndef is_valid_age[age]:\\n    return 0 <= age <= 150",
          "@STATICMETHOD\\NDEF IS_VALID_AGE(AGE):\\N    RETURN 0 <= AGE <= 150"
        ],
        "correctAnswer": "@staticmethod\\ndef is_valid_age(age):\\n    return 0 <= age <= 150",
        "explanation": "Static methods are utility functions that don't need access to instance or class state."
      },
      {
        "id": "19",
        "type": "text-input",
        "question": "What is operator overloading?",
        "correctAnswer": "defining custom behavior for operators",
        "explanation": "Special methods like __add__, __sub__ allow classes to define how operators work with their instances."
      },
      {
        "id": "20",
        "type": "multiple-choice",
        "question": "Write a class that overloads the + operator.",
        "options": [
          "class Vector:\\n    def __init__(self, x, y):\\n        self.x, self.y = x, y\\n    \\n    def __add__(self, other):\\n        return Vector(self.x + other.x, self.y + other.y)",
          "#class Vector:\\n    def __init__(self, x, y):\\n        self.x, self.y = x, y\\n    \\n    def __add__(self, other):\\n        return Vector(self.x + other.x, self.y + other.y)",
          "class Vector:\\n    def __init__[self, x, y]:\\n        self.x, self.y = x, y\\n    \\n    def __add__[self, other]:\\n        return Vector[self.x + other.x, self.y + other.y]",
          "CLASS VECTOR:\\N    DEF __INIT__(SELF, X, Y):\\N        SELF.X, SELF.Y = X, Y\\N    \\N    DEF __ADD__(SELF, OTHER):\\N        RETURN VECTOR(SELF.X + OTHER.X, SELF.Y + OTHER.Y)"
        ],
        "correctAnswer": "class Vector:\\n    def __init__(self, x, y):\\n        self.x, self.y = x, y\\n    \\n    def __add__(self, other):\\n        return Vector(self.x + other.x, self.y + other.y)",
        "explanation": "__add__ defines behavior for the + operator between Vector instances."
      },
      {
        "id": "21",
        "type": "multiple-choice",
        "question": "What is the __str__ method used for?",
        "options": [
          "String representation for end users",
          "Internal string representation",
          "Both",
          "Neither"
        ],
        "correctAnswer": "String representation for end users",
        "explanation": "__str__ should return a readable string representation, while __repr__ is for developers."
      },
      {
        "id": "22",
        "type": "multiple-choice",
        "question": "Write a class with __str__ and __repr__ methods.",
        "options": [
          "class Person:\\n    def __init__(self, name, age):\\n        self.name, self.age = name, age\\n    \\n    def __str__(self):\\n        return f'{self.name} ({self.age})'\\n    \\n    def __repr__(self):\\n        return f'Person({self.name!r}, {self.age})'",
          "#class Person:\\n    def __init__(self, name, age):\\n        self.name, self.age = name, age\\n    \\n    def __str__(self):\\n        return f'{self.name} ({self.age})'\\n    \\n    def __repr__(self):\\n        return f'Person({self.name!r}, {self.age})'",
          "class Person:\\n    def __init__[self, name, age]:\\n        self.name, self.age = name, age\\n    \\n    def __str__[self]:\\n        return f'{self.name} [{self.age}]'\\n    \\n    def __repr__[self]:\\n        return f'Person[{self.name!r}, {self.age}]'",
          "CLASS PERSON:\\N    DEF __INIT__(SELF, NAME, AGE):\\N        SELF.NAME, SELF.AGE = NAME, AGE\\N    \\N    DEF __STR__(SELF):\\N        RETURN F'{SELF.NAME} ({SELF.AGE})'\\N    \\N    DEF __REPR__(SELF):\\N        RETURN F'PERSON({SELF.NAME!R}, {SELF.AGE})'"
        ],
        "correctAnswer": "class Person:\\n    def __init__(self, name, age):\\n        self.name, self.age = name, age\\n    \\n    def __str__(self):\\n        return f'{self.name} ({self.age})'\\n    \\n    def __repr__(self):\\n        return f'Person({self.name!r}, {self.age})'",
        "explanation": "__str__ for user-friendly output, __repr__ for unambiguous representation."
      },
      {
        "id": "23",
        "type": "text-input",
        "question": "What is duck typing in Python?",
        "correctAnswer": "checking behavior rather than type",
        "explanation": "Duck typing focuses on what an object can do rather than what type it is."
      },
      {
        "id": "24",
        "type": "multiple-choice",
        "question": "What is the Liskov Substitution Principle?",
        "options": [
          "Subclasses should be substitutable for their parent classes",
          "Classes should depend on abstractions",
          "Software should be open for extension",
          "High-level modules shouldn't depend on low-level modules"
        ],
        "correctAnswer": "Subclasses should be substitutable for their parent classes",
        "explanation": "The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of a subclass without breaking the program."
      },
      {
        "id": "25",
        "type": "text-input",
        "question": "What is composition in OOP?",
        "correctAnswer": "building complex objects from simpler ones",
        "explanation": "Composition creates complex objects by combining simpler objects, often preferred over inheritance."
      },
      {
        "id": "26",
        "type": "multiple-choice",
        "question": "Write an example of composition.",
        "options": [
          "class Engine:\\n    def start(self): return 'Engine started'\\n\\nclass Car:\\n    def __init__(self):\\n        self.engine = Engine()\\n    \\n    def start(self):\\n        return self.engine.start()",
          "#class Engine:\\n    def start(self): return 'Engine started'\\n\\nclass Car:\\n    def __init__(self):\\n        self.engine = Engine()\\n    \\n    def start(self):\\n        return self.engine.start()",
          "class Engine:\\n    def start[self]: return 'Engine started'\\n\\nclass Car:\\n    def __init__[self]:\\n        self.engine = Engine[]\\n    \\n    def start[self]:\\n        return self.engine.start[]",
          "CLASS ENGINE:\\N    DEF START(SELF): RETURN 'ENGINE STARTED'\\N\\NCLASS CAR:\\N    DEF __INIT__(SELF):\\N        SELF.ENGINE = ENGINE()\\N    \\N    DEF START(SELF):\\N        RETURN SELF.ENGINE.START()"
        ],
        "correctAnswer": "class Engine:\\n    def start(self): return 'Engine started'\\n\\nclass Car:\\n    def __init__(self):\\n        self.engine = Engine()\\n    \\n    def start(self):\\n        return self.engine.start()",
        "explanation": "Car 'has-a' Engine, demonstrating composition over inheritance."
      },
      {
        "id": "27",
        "type": "multiple-choice",
        "question": "What is a mixin class?",
        "options": [
          "A class designed to be inherited with other classes",
          "A class with only static methods",
          "A class with no methods",
          "An abstract base class"
        ],
        "correctAnswer": "A class designed to be inherited with other classes",
        "explanation": "Mixin classes provide specific functionality that can be combined with other classes through multiple inheritance."
      },
      {
        "id": "28",
        "type": "text-input",
        "question": "What is an abstract base class (ABC)?",
        "correctAnswer": "a class that cannot be instantiated and defines interface",
        "explanation": "ABC defines methods that must be implemented by subclasses, using the abc module."
      },
      {
        "id": "29",
        "type": "multiple-choice",
        "question": "Write an abstract base class with abc module.",
        "options": [
          "from abc import ABC, abstractmethod\\n\\nclass Shape(ABC):\\n    @abstractmethod\\n    def area(self):\\n        pass\\n    \\n    @abstractmethod\\n    def perimeter(self):\\n        pass",
          "#from abc import ABC, abstractmethod\\n\\nclass Shape(ABC):\\n    @abstractmethod\\n    def area(self):\\n        pass\\n    \\n    @abstractmethod\\n    def perimeter(self):\\n        pass",
          "from abc import ABC, abstractmethod\\n\\nclass Shape[ABC]:\\n    @abstractmethod\\n    def area[self]:\\n        pass\\n    \\n    @abstractmethod\\n    def perimeter[self]:\\n        pass",
          "FROM ABC IMPORT ABC, ABSTRACTMETHOD\\N\\NCLASS SHAPE(ABC):\\N    @ABSTRACTMETHOD\\N    DEF AREA(SELF):\\N        PASS\\N    \\N    @ABSTRACTMETHOD\\N    DEF PERIMETER(SELF):\\N        PASS"
        ],
        "correctAnswer": "from abc import ABC, abstractmethod\\n\\nclass Shape(ABC):\\n    @abstractmethod\\n    def area(self):\\n        pass\\n    \\n    @abstractmethod\\n    def perimeter(self):\\n        pass",
        "explanation": "Abstract methods are decorated with @abstractmethod and must be implemented by subclasses."
      },
      {
        "id": "30",
        "type": "multiple-choice",
        "question": "What is the difference between isinstance() and issubclass()?",
        "options": [
          "isinstance checks objects, issubclass checks classes",
          "They are the same",
          "isinstance works on classes, issubclass on objects",
          "Neither checks inheritance"
        ],
        "correctAnswer": "isinstance checks objects, issubclass checks classes",
        "explanation": "isinstance(obj, cls) checks if obj is an instance of cls, issubclass(child, parent) checks class inheritance."
      }
    ]
  }
]