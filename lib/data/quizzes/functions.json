[
  {
    "id": "1",
    "title": "Defining Functions",
    "description": "Practice creating and calling functions.",
    "difficulty": "beginner",
    "questions": [
      {
        "id": "1",
        "type": "multiple-choice",
        "question": "Which keyword is used to define a function in Python?",
        "options": [
          "func",
          "def",
          "function",
          "define"
        ],
        "correctAnswer": "def",
        "explanation": "The \"def\" keyword is used to define a function in Python."
      },
      {
        "id": "2",
        "type": "text-input",
        "question": "What is the syntax to define a function that takes no parameters?",
        "correctAnswer": "def function_name():",
        "explanation": "Functions are defined with \"def\" followed by the name and parentheses."
      },
      {
        "id": "3",
        "type": "multiple-choice",
        "question": "Write a function that takes two numbers and returns their sum.",
        "options": [
          "def add_numbers(a, b):\\n    return a + b",
          "#def add_numbers(a, b):\\n    return a + b",
          "def add_numbers[a, b]:\\n    return a + b",
          "DEF ADD_NUMBERS(A, B):\\N    RETURN A + B"
        ],
        "correctAnswer": "def add_numbers(a, b):\\n    return a + b",
        "explanation": "Functions use 'def', parameters in parentheses, and 'return' to send back values."
      },
      {
        "id": "4",
        "type": "multiple-choice",
        "question": "What happens if a function doesn't have a return statement?",
        "options": [
          "It returns None",
          "It returns 0",
          "It returns an empty string",
          "It causes an error"
        ],
        "correctAnswer": "It returns None",
        "explanation": "Functions without return statements implicitly return None."
      },
      {
        "id": "5",
        "type": "multiple-choice",
        "question": "Write code to call a function named 'greet' with the argument 'Alice'.",
        "options": [
          "greet('Alice')",
          "#greet('Alice')",
          "greet['Alice']",
          "GREET('ALICE')"
        ],
        "correctAnswer": "greet('Alice')",
        "explanation": "Function calls use the function name followed by parentheses containing arguments."
      },
      {
        "id": "6",
        "type": "text-input",
        "question": "What is a default parameter in a function?",
        "correctAnswer": "a parameter with a default value",
        "explanation": "Default parameters have values assigned in the function definition and are optional when calling."
      },
      {
        "id": "7",
        "type": "multiple-choice",
        "question": "Write a function with a default parameter that greets someone.",
        "options": [
          "def greet(name='World'):\\n    return f'Hello, {name}!'",
          "#def greet(name='World'):\\n    return f'Hello, {name}!'",
          "def greet[name='World']:\\n    return f'Hello, {name}!'",
          "DEF GREET(NAME='WORLD'):\\N    RETURN F'HELLO, {NAME}!'"
        ],
        "correctAnswer": "def greet(name='World'):\\n    return f'Hello, {name}!'",
        "explanation": "Default parameters are specified with = in the function definition."
      },
      {
        "id": "8",
        "type": "multiple-choice",
        "question": "What is function scope?",
        "options": [
          "Where functions are defined",
          "The accessibility of variables in a function",
          "The number of parameters",
          "The return type"
        ],
        "correctAnswer": "The accessibility of variables in a function",
        "explanation": "Scope determines where variables can be accessed - local vs global."
      },
      {
        "id": "9",
        "type": "multiple-choice",
        "question": "Write code that demonstrates a local variable in a function.",
        "options": [
          "def my_function():\\n    local_var = 10\\n    return local_var",
          "#def my_function():\\n    local_var = 10\\n    return local_var",
          "def my_function[]:\\n    local_var = 10\\n    return local_var",
          "DEF MY_FUNCTION():\\N    LOCAL_VAR = 10\\N    RETURN LOCAL_VAR"
        ],
        "correctAnswer": "def my_function():\\n    local_var = 10\\n    return local_var",
        "explanation": "Variables defined inside functions are local to that function."
      },
      {
        "id": "10",
        "type": "text-input",
        "question": "How do you access a global variable inside a function?",
        "correctAnswer": "use the global keyword",
        "explanation": "The global keyword allows functions to modify global variables."
      },
      {
        "id": "11",
        "type": "multiple-choice",
        "question": "Write a function that uses *args to accept multiple arguments.",
        "options": [
          "def sum_all(*args):\\n    return sum(args)",
          "#def sum_all(*args):\\n    return sum(args)",
          "def sum_all[*args]:\\n    return sum[args]",
          "DEF SUM_ALL(*ARGS):\\N    RETURN SUM(ARGS)"
        ],
        "correctAnswer": "def sum_all(*args):\\n    return sum(args)",
        "explanation": "*args allows functions to accept a variable number of positional arguments."
      },
      {
        "id": "12",
        "type": "multiple-choice",
        "question": "Write a function that uses **kwargs for keyword arguments.",
        "options": [
          "def print_info(**kwargs):\\n    for key, value in kwargs.items():\\n        print(f'{key}: {value}')",
          "#def print_info(**kwargs):\\n    for key, value in kwargs.items():\\n        print(f'{key}: {value}')",
          "def print_info[**kwargs]:\\n    for key, value in kwargs.items[]:\\n        print[f'{key}: {value}']",
          "DEF PRINT_INFO(**KWARGS):\\N    FOR KEY, VALUE IN KWARGS.ITEMS():\\N        PRINT(F'{KEY}: {VALUE}')"
        ],
        "correctAnswer": "def print_info(**kwargs):\\n    for key, value in kwargs.items():\\n        print(f'{key}: {value}')",
        "explanation": "**kwargs allows functions to accept a variable number of keyword arguments."
      },
      {
        "id": "13",
        "type": "multiple-choice",
        "question": "What is a lambda function?",
        "options": [
          "An anonymous function",
          "A named function",
          "A recursive function",
          "A built-in function"
        ],
        "correctAnswer": "An anonymous function",
        "explanation": "Lambda functions are small anonymous functions defined with the lambda keyword."
      },
      {
        "id": "14",
        "type": "multiple-choice",
        "question": "Write a lambda function that squares a number.",
        "options": [
          "lambda x: x ** 2",
          "#lambda x: x ** 2",
          "lambda x: x ** 2",
          "LAMBDA X: X ** 2"
        ],
        "correctAnswer": "lambda x: x ** 2",
        "explanation": "Lambda syntax: lambda parameters: expression"
      },
      {
        "id": "15",
        "type": "text-input",
        "question": "What is a docstring in Python?",
        "correctAnswer": "a string literal documenting a function",
        "explanation": "Docstrings are triple-quoted strings that document functions, classes, and modules."
      },
      {
        "id": "16",
        "type": "multiple-choice",
        "question": "Write a function with a docstring.",
        "options": [
          "def add(a, b):\\n    '''Add two numbers and return the result.'''\\n    return a + b",
          "#def add(a, b):\\n    '''Add two numbers and return the result.'''\\n    return a + b",
          "def add[a, b]:\\n    '''Add two numbers and return the result.'''\\n    return a + b",
          "DEF ADD(A, B):\\N    '''ADD TWO NUMBERS AND RETURN THE RESULT.'''\\N    RETURN A + B"
        ],
        "correctAnswer": "def add(a, b):\\n    '''Add two numbers and return the result.'''\\n    return a + b",
        "explanation": "Docstrings are placed immediately after the function definition."
      },
      {
        "id": "17",
        "type": "multiple-choice",
        "question": "What is function recursion?",
        "options": [
          "A function calling itself",
          "A function calling other functions",
          "Multiple functions with the same name",
          "Functions defined inside other functions"
        ],
        "correctAnswer": "A function calling itself",
        "explanation": "Recursion occurs when a function calls itself to solve a problem."
      },
      {
        "id": "18",
        "type": "multiple-choice",
        "question": "Write a recursive function to calculate factorial.",
        "options": [
          "def factorial(n):\\n    if n <= 1:\\n        return 1\\n    return n * factorial(n - 1)",
          "#def factorial(n):\\n    if n <= 1:\\n        return 1\\n    return n * factorial(n - 1)",
          "def factorial[n]:\\n    if n <= 1:\\n        return 1\\n    return n * factorial[n - 1]",
          "DEF FACTORIAL(N):\\N    IF N <= 1:\\N        RETURN 1\\N    RETURN N * FACTORIAL(N - 1)"
        ],
        "correctAnswer": "def factorial(n):\\n    if n <= 1:\\n        return 1\\n    return n * factorial(n - 1)",
        "explanation": "Recursive functions have a base case and call themselves with modified parameters."
      },
      {
        "id": "19",
        "type": "text-input",
        "question": "What is a higher-order function?",
        "correctAnswer": "a function that takes other functions as arguments",
        "explanation": "Higher-order functions can accept functions as parameters or return functions."
      },
      {
        "id": "20",
        "type": "multiple-choice",
        "question": "Write code using map() function with a lambda.",
        "options": [
          "list(map(lambda x: x * 2, [1, 2, 3]))",
          "#list(map(lambda x: x * 2, [1, 2, 3]))",
          "list[map[lambda x: x * 2, [1, 2, 3]]]",
          "LIST(MAP(LAMBDA X: X * 2, [1, 2, 3]))"
        ],
        "correctAnswer": "list(map(lambda x: x * 2, [1, 2, 3]))",
        "explanation": "map() applies a function to each item in an iterable."
      },
      {
        "id": "21",
        "type": "multiple-choice",
        "question": "Write a function that accepts variable positional arguments and returns their sum.",
        "options": [
          "def sum_all(*args):\\n    return sum(args)",
          "#def sum_all(*args):\\n    return sum(args)",
          "def sum_all[*args]:\\n    return sum[args]",
          "DEF SUM_ALL(*ARGS):\\N    RETURN SUM(ARGS)"
        ],
        "correctAnswer": "def sum_all(*args):\\n    return sum(args)",
        "explanation": "*args allows the function to accept any number of positional arguments."
      },
      {
        "id": "22",
        "type": "multiple-choice",
        "question": "Write a function that accepts keyword arguments and prints them.",
        "options": [
          "def print_kwargs(**kwargs):\\n    for key, value in kwargs.items():\\n        print(f'{key}: {value}')",
          "#def print_kwargs(**kwargs):\\n    for key, value in kwargs.items():\\n        print(f'{key}: {value}')",
          "def print_kwargs[**kwargs]:\\n    for key, value in kwargs.items[]:\\n        print[f'{key}: {value}']",
          "DEF PRINT_KWARGS(**KWARGS):\\N    FOR KEY, VALUE IN KWARGS.ITEMS():\\N        PRINT(F'{KEY}: {VALUE}')"
        ],
        "correctAnswer": "def print_kwargs(**kwargs):\\n    for key, value in kwargs.items():\\n        print(f'{key}: {value}')",
        "explanation": "**kwargs allows the function to accept any number of keyword arguments."
      },
      {
        "id": "23",
        "type": "multiple-choice",
        "question": "What is the difference between *args and **kwargs?",
        "options": [
          "*args is for keywords, **kwargs is for positional",
          "**kwargs is for keywords, *args is for positional",
          "They are the same",
          "Neither accepts multiple arguments"
        ],
        "correctAnswer": "**kwargs is for keywords, *args is for positional",
        "explanation": "*args collects positional arguments as a tuple, **kwargs collects keyword arguments as a dictionary."
      },
      {
        "id": "24",
        "type": "multiple-choice",
        "question": "Write a function with both *args and **kwargs.",
        "options": [
          "def func(a, b, *args, **kwargs):\\n    print(f'Required: {a}, {b}')\\n    print(f'Args: {args}')\\n    print(f'kwargs: {kwargs}')",
          "#def func(a, b, *args, **kwargs):\\n    print(f'Required: {a}, {b}')\\n    print(f'Args: {args}')\\n    print(f'kwargs: {kwargs}')",
          "def func[a, b, *args, **kwargs]:\\n    print[f'Required: {a}, {b}']\\n    print[f'Args: {args}']\\n    print[f'kwargs: {kwargs}']",
          "DEF FUNC(A, B, *ARGS, **KWARGS):\\N    PRINT(F'REQUIRED: {A}, {B}')\\N    PRINT(F'ARGS: {ARGS}')\\N    PRINT(F'KWARGS: {KWARGS}')"
        ],
        "correctAnswer": "def func(a, b, *args, **kwargs):\\n    print(f'Required: {a}, {b}')\\n    print(f'Args: {args}')\\n    print(f'kwargs: {kwargs}')",
        "explanation": "Functions can have required parameters, *args, and **kwargs in that order."
      },
      {
        "id": "25",
        "type": "text-input",
        "question": "What is a closure in Python?",
        "correctAnswer": "a function that remembers variables from its enclosing scope",
        "explanation": "Closures allow inner functions to access variables from outer functions even after the outer function has finished."
      },
      {
        "id": "26",
        "type": "multiple-choice",
        "question": "Write an example of a closure.",
        "options": [
          "def outer(x):\\n    def inner(y):\\n        return x + y\\n    return inner\\n\\nclosure = outer(10)\\nprint(closure(5))  # Outputs 15",
          "#def outer(x):\\n    def inner(y):\\n        return x + y\\n    return inner\\n\\nclosure = outer(10)\\nprint(closure(5))  # Outputs 15",
          "def outer[x]:\\n    def inner[y]:\\n        return x + y\\n    return inner\\n\\nclosure = outer[10]\\nprint[closure[5]]  # Outputs 15",
          "DEF OUTER(X):\\N    DEF INNER(Y):\\N        RETURN X + Y\\N    RETURN INNER\\N\\NCLOSURE = OUTER(10)\\NPRINT(CLOSURE(5))  # OUTPUTS 15"
        ],
        "correctAnswer": "def outer(x):\\n    def inner(y):\\n        return x + y\\n    return inner\\n\\nclosure = outer(10)\\nprint(closure(5))  # Outputs 15",
        "explanation": "The inner function 'remembers' the value of x from the outer function."
      },
      {
        "id": "27",
        "type": "text-input",
        "question": "What is a decorator in Python?",
        "correctAnswer": "a function that takes another function and extends its behavior",
        "explanation": "Decorators are used to modify the behavior of functions or classes without changing their source code."
      },
      {
        "id": "28",
        "type": "multiple-choice",
        "question": "Write a simple decorator that prints before and after function execution.",
        "options": [
          "def my_decorator(func):\\n    def wrapper(*args, **kwargs):\\n        print('Before')\\n        result = func(*args, **kwargs)\\n        print('After')\\n        return result\\n    return wrapper",
          "#def my_decorator(func):\\n    def wrapper(*args, **kwargs):\\n        print('Before')\\n        result = func(*args, **kwargs)\\n        print('After')\\n        return result\\n    return wrapper",
          "def my_decorator[func]:\\n    def wrapper[*args, **kwargs]:\\n        print['Before']\\n        result = func[*args, **kwargs]\\n        print['After']\\n        return result\\n    return wrapper",
          "DEF MY_DECORATOR(FUNC):\\N    DEF WRAPPER(*ARGS, **KWARGS):\\N        PRINT('BEFORE')\\N        RESULT = FUNC(*ARGS, **KWARGS)\\N        PRINT('AFTER')\\N        RETURN RESULT\\N    RETURN WRAPPER"
        ],
        "correctAnswer": "def my_decorator(func):\\n    def wrapper(*args, **kwargs):\\n        print('Before')\\n        result = func(*args, **kwargs)\\n        print('After')\\n        return result\\n    return wrapper",
        "explanation": "Decorators typically return a wrapper function that adds functionality around the original function."
      },
      {
        "id": "29",
        "type": "multiple-choice",
        "question": "Write code using the @ decorator syntax.",
        "options": [
          "@my_decorator\\ndef my_function():\\n    print('Hello')",
          "#@my_decorator\\ndef my_function():\\n    print('Hello')",
          "@my_decorator\\ndef my_function[]:\\n    print['Hello']",
          "@MY_DECORATOR\\NDEF MY_FUNCTION():\\N    PRINT('HELLO')"
        ],
        "correctAnswer": "@my_decorator\\ndef my_function():\\n    print('Hello')",
        "explanation": "The @ symbol is syntactic sugar for applying decorators to functions."
      },
      {
        "id": "30",
        "type": "multiple-choice",
        "question": "What is the output of this code: filter(lambda x: x > 2, [1, 2, 3, 4])?",
        "options": [
          "[3, 4]",
          "<filter object>",
          "Error",
          "[1, 2]"
        ],
        "correctAnswer": "<filter object>",
        "explanation": "filter() returns a filter object, not a list. Use list() to convert it."
      },
      {
        "id": "31",
        "type": "multiple-choice",
        "question": "Write code using filter() to get even numbers from a list.",
        "options": [
          "list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5]))",
          "#list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5]))",
          "list[filter[lambda x: x % 2 == 0, [1, 2, 3, 4, 5]]]",
          "LIST(FILTER(LAMBDA X: X % 2 == 0, [1, 2, 3, 4, 5]))"
        ],
        "correctAnswer": "list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5]))",
        "explanation": "filter() takes a function and an iterable, returning items where the function returns True."
      },
      {
        "id": "32",
        "type": "multiple-choice",
        "question": "Write code using reduce() to sum a list (requires functools import).",
        "options": [
          "from functools import reduce\\nreduce(lambda x, y: x + y, [1, 2, 3, 4])",
          "#from functools import reduce\\nreduce(lambda x, y: x + y, [1, 2, 3, 4])",
          "from functools import reduce\\nreduce[lambda x, y: x + y, [1, 2, 3, 4]]",
          "FROM FUNCTOOLS IMPORT REDUCE\\NREDUCE(LAMBDA X, Y: X + Y, [1, 2, 3, 4])"
        ],
        "correctAnswer": "from functools import reduce\\nreduce(lambda x, y: x + y, [1, 2, 3, 4])",
        "explanation": "reduce() applies a function cumulatively to the items of an iterable."
      },
      {
        "id": "33",
        "type": "text-input",
        "question": "What is partial application?",
        "correctAnswer": "fixing some arguments of a function to create a new function",
        "explanation": "Partial application creates a new function with some arguments pre-filled."
      },
      {
        "id": "34",
        "type": "multiple-choice",
        "question": "Write code using partial from functools.",
        "options": [
          "from functools import partial\\nadd_five = partial(add, 5)\\nprint(add_five(3))  # Outputs 8",
          "#from functools import partial\\nadd_five = partial(add, 5)\\nprint(add_five(3))  # Outputs 8",
          "from functools import partial\\nadd_five = partial[add, 5]\\nprint[add_five[3]]  # Outputs 8",
          "FROM FUNCTOOLS IMPORT PARTIAL\\NADD_FIVE = PARTIAL(ADD, 5)\\NPRINT(ADD_FIVE(3))  # OUTPUTS 8"
        ],
        "correctAnswer": "from functools import partial\\nadd_five = partial(add, 5)\\nprint(add_five(3))  # Outputs 8",
        "explanation": "partial() fixes some arguments and returns a new function with the remaining arguments."
      },
      {
        "id": "35",
        "type": "multiple-choice",
        "question": "What is a pure function?",
        "options": [
          "A function with no side effects",
          "A function that returns None",
          "A recursive function",
          "A function with default parameters"
        ],
        "correctAnswer": "A function with no side effects",
        "explanation": "Pure functions don't modify external state and always return the same result for the same inputs."
      }
    ]
  }
]